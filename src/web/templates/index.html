<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChessGemma - AI Chess Assistant</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --chess-dark: #769656;
            --chess-light: #eeeed2;
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            margin: 0;
        }

        .navbar-brand {
            font-weight: 700;
            font-size: 1.5rem;
        }

        .main-container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        .chess-board {
            width: 400px;
            height: 400px;
            margin: 2rem auto;
            border: 3px solid var(--primary-color);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            background: var(--chess-light);
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
        }

        .chess-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chess-square.dark {
            background: var(--chess-dark);
        }

        .chess-square.light {
            background: var(--chess-light);
        }

        .chess-square:hover {
            background: rgba(255, 255, 0, 0.3) !important;
            transform: scale(1.05);
        }

        .chess-square.selected {
            background: rgba(0, 123, 255, 0.4) !important;
            border: 2px solid #007bff;
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.5);
        }

        .chess-square {
            transition: all 0.2s ease;
            cursor: pointer;
            user-select: none;
        }

        .chess-square.legal-move {
            background: rgba(0, 255, 0, 0.3) !important;
            border: 2px solid #00ff00;
            transform: scale(1.05);
        }

        .chess-square.legal-move:hover {
            background: rgba(0, 255, 0, 0.5) !important;
            transform: scale(1.1);
        }

        .play-mode-active {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%) !important;
            color: white !important;
            border: 2px solid #ff4757 !important;
        }

        .analysis-mode-active {
            background: linear-gradient(135deg, #3742fa 0%, #2f3542 100%) !important;
            color: white !important;
            border: 2px solid #5352ed !important;
        }

        .chat-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            margin: 2rem 0;
            overflow: hidden;
        }

        .chat-messages {
            height: 400px;
            overflow-y: auto;
            padding: 1rem;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            max-width: 80%;
        }

        .message.user {
            background: var(--secondary-color);
            color: white;
            margin-left: auto;
            text-align: right;
        }

        .message.assistant {
            background: white;
            border: 1px solid #e9ecef;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .confidence-badge {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            margin-top: 0.25rem;
            display: inline-block;
        }

        .confidence-high { background: #d4edda; color: #155724; }
        .confidence-medium { background: #fff3cd; color: #856404; }
        .confidence-low { background: #f8d7da; color: #721c24; }

        .input-group {
            border-top: 1px solid #e9ecef;
            padding: 1rem;
            background: white;
        }

        .btn-primary {
            background: var(--secondary-color);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 500;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .examples-section {
            margin-top: 2rem;
        }

        .example-btn {
            margin: 0.25rem;
            padding: 0.5rem 1rem;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .example-btn:hover {
            background: var(--secondary-color);
            color: white;
            border-color: var(--secondary-color);
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--secondary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .navbar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .card {
            border: none;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .welcome-section {
            text-align: center;
            color: white;
            margin-bottom: 2rem;
        }

        .welcome-section h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .welcome-section p {
            font-size: 1.2rem;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-light">
        <div class="container">
            <a class="navbar-brand" href="#">
                <i class="fas fa-chess-knight me-2"></i>
                ChessGemma
            </a>
            <div class="navbar-nav ms-auto">
                <span class="nav-item nav-link">
                    <i class="fas fa-circle text-success me-1"></i>
                    AI Chess Assistant Online
                </span>
            </div>
        </div>
    </nav>

    <div class="main-container">
        <div class="welcome-section">
            <h1><i class="fas fa-chess-queen me-3"></i>ChessGemma</h1>
            <p>Your AI-powered chess analysis and learning companion</p>
        </div>

        <div class="row">
            <div class="col-lg-8">
                <div class="card chat-container">
                    <div class="chat-messages" id="chatMessages">
                        <div class="message assistant">
                            <div class="d-flex align-items-center mb-2">
                                <i class="fas fa-robot me-2"></i>
                                <strong>ChessGemma</strong>
                            </div>
                            <p>Hello! I'm your AI chess assistant. Ask me anything about chess strategy, openings, tactics, or endgames. I can help you improve your game!</p>
                        </div>
                    </div>

                    <div class="input-group">
                        <div class="input-group">
                            <input type="text" class="form-control" id="questionInput"
                                   placeholder="Ask a chess question..."
                                   onkeypress="handleKeyPress(event)">
                            <button class="btn btn-primary" onclick="askQuestion()">
                                <i class="fas fa-paper-plane me-2"></i>
                                Ask
                            </button>
                        </div>
                    </div>
                </div>

                <div class="examples-section">
                    <h5 class="text-white mb-3">Try these example questions:</h5>
                    <div id="examplesContainer">
                        <!-- Examples will be loaded here -->
                    </div>
                </div>
            </div>

            <div class="col-lg-4">
                <div class="card">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            <i class="fas fa-chess-board me-2"></i>
                            Chess Board
                        </h5>
                    </div>
                    <div class="card-body">
                        <div class="chess-board" id="chessBoard">
                            <!-- Chess board will be rendered here -->
                        </div>
                        <div class="text-center mt-3">
                            <small class="text-muted">
                                Interactive chess board visualization
                            </small>
        <div class="mt-2">
            <button class="btn btn-sm btn-primary me-2" onclick="toggleGameMode()">
                <i class="fas fa-gamepad me-1"></i>
                Toggle Play Mode
            </button>
            <button class="btn btn-sm btn-secondary me-2" onclick="resetGame()">
                <i class="fas fa-refresh me-1"></i>
                Reset Game
            </button>
            <button class="btn btn-sm btn-warning me-2" onclick="toggleStockfishMatch()">
                <i class="fas fa-chess me-1"></i>
                Stockfish Match
            </button>
            <button class="btn btn-sm btn-info" onclick="testStockfish()">
                <i class="fas fa-vial me-1"></i>
                Test Stockfish
            </button>
        </div>
                        </div>
                    </div>
                </div>

                <div class="card mt-3">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            <i class="fas fa-info-circle me-2"></i>
                            About ChessGemma
                        </h5>
                    </div>
                    <div class="card-body">
                        <p class="mb-2">
                            <strong>Model:</strong> Gemma-3 270M fine-tuned for chess
                        </p>
                        <p class="mb-2">
                            <strong>Capabilities:</strong>
                        </p>
                        <ul class="list-unstyled small">
                            <li><i class="fas fa-check text-success me-1"></i> Opening analysis</li>
                            <li><i class="fas fa-check text-success me-1"></i> Tactical explanations</li>
                            <li><i class="fas fa-check text-success me-1"></i> Strategic guidance</li>
                            <li><i class="fas fa-check text-success me-1"></i> Endgame principles</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Global variables
        let isLoading = false;
        let gameState = null;
        let selectedSquare = null;
        let selectedSquareIndex = null;
        let gameMode = 'analysis'; // 'analysis' or 'play'
        let stockfishMatch = null;
        let matchActive = false;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeChessBoard();
            loadExamples();
            setupEventListeners();
            loadGameState();
            
            // Show welcome message
            showMessage('üéÆ **ChessGemma Ready!**\n\nClick squares to analyze positions or toggle Play Mode to start a game!', 'success');
        });

        // Initialize chess board
        function initializeChessBoard() {
            const board = document.getElementById('chessBoard');
            board.innerHTML = '';
            for (let i = 0; i < 64; i++) {
                const square = document.createElement('div');
                square.className = `chess-square ${(i + Math.floor(i / 8)) % 2 === 0 ? 'light' : 'dark'}`;
                square.onclick = () => handleSquareClick(i);
                board.appendChild(square);
            }
        }

        // Load example questions
        async function loadExamples() {
            try {
                const response = await fetch('/api/examples');
                const data = await response.json();
                const container = document.getElementById('examplesContainer');

                data.examples.forEach(example => {
                    const button = document.createElement('button');
                    button.className = 'example-btn';
                    button.textContent = example;
                    button.onclick = () => useExample(example);
                    container.appendChild(button);
                });
            } catch (error) {
                console.error('Failed to load examples:', error);
            }
        }

        // Handle example question click
        function useExample(question) {
            document.getElementById('questionInput').value = question;
            askQuestion();
        }

        // Handle Enter key in input
        function handleKeyPress(event) {
            if (event.key === 'Enter' && !isLoading) {
                askQuestion();
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Add any additional event listeners here
        }

        // Ask a question
        async function askQuestion() {
            if (isLoading) return;

            const input = document.getElementById('questionInput');
            const question = input.value.trim();

            if (!question) {
                showMessage('Please enter a question.', 'error');
                return;
            }

            // Add user message
            addMessage(question, 'user');
            input.value = '';
            isLoading = true;

            // Show loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'message assistant';
            loadingDiv.innerHTML = `
                <div class="d-flex align-items-center">
                    <i class="fas fa-robot me-2"></i>
                    <strong>ChessGemma</strong>
                    <div class="loading ms-2"></div>
                </div>
                <p>Thinking about your question...</p>
            `;
            document.getElementById('chatMessages').appendChild(loadingDiv);
            scrollToBottom();

            try {
                const response = await fetch('/api/ask', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        question: question,
                        context: '' // Add context if needed
                    })
                });

                const data = await response.json();

                // Remove loading indicator
                loadingDiv.remove();

                // Add assistant response
                let messageClass = 'assistant';
                let confidenceClass = 'confidence-low';

                if (data.confidence > 0.7) {
                    confidenceClass = 'confidence-high';
                } else if (data.confidence > 0.4) {
                    confidenceClass = 'confidence-medium';
                }

                const confidenceText = data.confidence ?
                    `<div class="confidence-badge ${confidenceClass}">Confidence: ${(data.confidence * 100).toFixed(1)}%</div>` : '';

                addMessage(`
                    <div class="d-flex align-items-center mb-2">
                        <i class="fas fa-robot me-2"></i>
                        <strong>ChessGemma</strong>
                    </div>
                    <p>${data.response || data.error || 'No response received'}</p>
                    ${confidenceText}
                `, messageClass);

            } catch (error) {
                console.error('Error:', error);
                loadingDiv.remove();
                addMessage('Sorry, I encountered an error while processing your question. Please try again.', 'error');
            } finally {
                isLoading = false;
            }
        }

        // Add message to chat
        function addMessage(content, type = 'assistant') {
            const messagesDiv = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.innerHTML = content;
            messagesDiv.appendChild(messageDiv);
            scrollToBottom();
        }

        // Scroll to bottom of chat
        function scrollToBottom() {
            const messagesDiv = document.getElementById('chatMessages');
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // Handle chess square clicks
        function handleSquareClick(squareIndex) {
            const file = String.fromCharCode(97 + (squareIndex % 8)); // a-h
            const rank = 8 - Math.floor(squareIndex / 8); // 1-8
            const square = `${file}${rank}`;

            console.log(`Clicked square: ${square}`);
            
            if (gameMode === 'play') {
                handlePlayModeClick(square, squareIndex);
            } else {
                handleAnalysisModeClick(square, squareIndex);
            }
        }

        // Handle clicks in analysis mode
        function handleAnalysisModeClick(square, squareIndex) {
            // Visual feedback for clicked square
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach(sq => sq.classList.remove('selected'));
            squares[squareIndex].classList.add('selected');
            
            // Get piece on this square
            const piece = squares[squareIndex].textContent;
            const pieceName = getPieceName(piece);
            
            // Show square info and ask if user wants to analyze this square
            const message = piece ? 
                `Selected square ${square} with ${pieceName}` : 
                `Selected empty square ${square}`;
            
            showMessage(message, 'info', 3000);
            
            // Auto-ask a question about this square with board context
            setTimeout(() => {
                const currentFEN = getCurrentBoardFEN();
                const question = piece ?
                    `FEN: ${currentFEN}\nQuestion: What can the ${pieceName} on ${square} do?` :
                    `FEN: ${currentFEN}\nQuestion: What pieces can move to ${square}?`;
                
                document.getElementById('questionInput').value = question;
                askQuestion();
            }, 1000);
        }

        // Handle clicks in play mode
        function handlePlayModeClick(square, squareIndex) {
            if (selectedSquare === null) {
                // First click - select piece
                selectedSquare = square;
                selectedSquareIndex = squareIndex;
                const squares = document.querySelectorAll('.chess-square');
                squares.forEach(sq => sq.classList.remove('selected'));
                squares[squareIndex].classList.add('selected');
                
                // Get legal moves for this piece
                getLegalMoves(square);
            } else {
                // Second click - make move with promotion handling
                let move = `${selectedSquare}${square}`;
                const squares = document.querySelectorAll('.chess-square');
                const fromPiece = squares[selectedSquareIndex]?.textContent;
                const destRank = parseInt(square[1]);
                if ((fromPiece === '‚ôô' && destRank === 8) || (fromPiece === '‚ôü' && destRank === 1)) {
                    let promo = (window.prompt('Promote to (q,r,b,n)?', 'q') || 'q').toLowerCase();
                    if (!['q','r','b','n'].includes(promo)) promo = 'q';
                    move = `${move}${promo}`;
                }
                makeMove(move);
                selectedSquare = null;
                selectedSquareIndex = null;
            }
        }

        // Get current board state as FEN
        function getCurrentBoardFEN() {
            if (gameState && gameState.fen) {
                return gameState.fen;
            }
            return "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
        }

        // Get piece name from Unicode symbol
        function getPieceName(piece) {
            const pieceNames = {
                '‚ôú': 'Black Rook', '‚ôû': 'Black Knight', '‚ôù': 'Black Bishop', 
                '‚ôõ': 'Black Queen', '‚ôö': 'Black King', '‚ôü': 'Black Pawn',
                '‚ôñ': 'White Rook', '‚ôò': 'White Knight', '‚ôó': 'White Bishop', 
                '‚ôï': 'White Queen', '‚ôî': 'White King', '‚ôô': 'White Pawn'
            };
            return pieceNames[piece] || 'Unknown Piece';
        }

        // Show a message (persistent by default)
        function showMessage(message, type = 'info', duration = 0) {
            addMessage(message, type);

            // Only auto-remove if duration is specified and > 0
            if (duration > 0) {
                setTimeout(() => {
                    const messages = document.querySelectorAll('.message');
                    if (messages.length > 0) {
                        messages[messages.length - 1].remove();
                    }
                }, duration);
            }
        }

        // Load game state from server
        async function loadGameState() {
            try {
                const response = await fetch('/api/game/state');
                gameState = await response.json();
                console.log('Game state loaded:', gameState);
                if (gameState && gameState.fen) {
                    initializeChessBoard();
                    updateBoardFromFEN(gameState.fen);
                }
            } catch (error) {
                console.error('Failed to load game state:', error);
            }
        }

        // Make a move
        async function makeMove(moveUCI) {
            try {
                console.log(`Making move: ${moveUCI}`);
                console.log(`Current game state:`, gameState);
                
                const response = await fetch('/api/game/move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ move: moveUCI })
                });
                
                const result = await response.json();
                console.log('Move result:', result);
                
                if (result.success) {
                    const moveText = result.san || result.move;
                    const playerText = result.current_player === 'white' ? 'White' : 'Black';
                    showMessage(`‚úÖ ${playerText} played: ${moveText}`, 'success');
                    updateBoardFromFEN(result.fen);
                    gameState = result;
                    
                    // Clear selection
                    selectedSquare = null;
                    const squares = document.querySelectorAll('.chess-square');
                    squares.forEach(sq => sq.classList.remove('selected', 'legal-move'));
                    
                    // If it's now the AI's turn, ask for AI move
                    if (result.current_player === 'black' && gameMode === 'play') {
                        showMessage('ü§ñ AI is thinking...', 'info', 3000);
                        setTimeout(() => getAIMove(), 2000); // Increased delay for smoother experience
                    }
                } else {
                    showMessage(`‚ùå Invalid move: ${result.error}`, 'danger');
                    console.error('Move failed:', result.error);
                }
            } catch (error) {
                console.error('Move error:', error);
                showMessage('‚ùå Error making move', 'danger');
            }
        }

        // Get AI move
        async function getAIMove() {
            try {
                showMessage('AI is thinking...', 'info', 2000);
                
                const response = await fetch('/api/game/ai_move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const moveText = result.san || result.move;
                    let aiMessage = `ü§ñ **AI played: ${moveText}**`;
                    
                    // Add AI reasoning if available
                    if (result.ai_response) {
                        // Show full AI response, but format it nicely
                        const reasoning = result.ai_response;
                        aiMessage += `\n\nüí≠ **AI Reasoning:**\n${reasoning}`;
                    }
                    
                    showMessage(aiMessage, 'info');
                    updateBoardFromFEN(result.fen);
                    gameState = result;
                } else {
                    showMessage(`‚ùå AI error: ${result.error}`, 'danger');
                }
            } catch (error) {
                console.error('AI move error:', error);
                showMessage('‚ùå Error getting AI move', 'danger');
            }
        }

        // Get legal moves for a piece
        async function getLegalMoves(square) {
            try {
                const response = await fetch('/api/game/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ square: square })
                });
                
                const analysis = await response.json();
                console.log('Legal moves for', square, ':', analysis.legal_moves);
                
                // Highlight legal moves on the board
                highlightLegalMoves(analysis.legal_moves);
                
                // Show analysis in chat
                let message = `üîç **${analysis.piece_name} on ${square}**\n`;
                message += `**Legal moves:** ${analysis.legal_moves.join(', ')}`;
                
                // Add RAG advice if available
                if (analysis.rag_advice && analysis.rag_advice.length > 0) {
                    message += `\n\nüìö **Chess Knowledge:**\n${analysis.rag_advice.join('\n')}`;
                }
                
                showMessage(message, 'info');
                
            } catch (error) {
                console.error('Analysis error:', error);
            }
        }

        // Highlight legal moves on the board
        function highlightLegalMoves(legalMoves) {
            // Remove existing highlights
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach(sq => sq.classList.remove('legal-move'));
            
            // Add highlights for legal moves
            legalMoves.forEach(move => {
                const toSquare = move.slice(2, 4); // Extract destination square
                const file = toSquare.charCodeAt(0) - 97; // a=0, b=1, etc.
                const rank = 8 - parseInt(toSquare[1]); // 1=7, 2=6, etc.
                const squareIndex = rank * 8 + file;
                
                if (squareIndex >= 0 && squareIndex < 64) {
                    squares[squareIndex].classList.add('legal-move');
                }
            });
        }

        // Update board from FEN
        function updateBoardFromFEN(fen) {
            console.log('Board updated to FEN:', fen);
            
            // Parse FEN and update the visual board
            const fenParts = fen.split(' ');
            const boardState = fenParts[0];
            const currentPlayer = fenParts[1];
            
            // Clear the board
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach(sq => {
                sq.textContent = '';
                sq.classList.remove('selected', 'legal-move');
            });
            
            // Parse board state and place pieces
            let rank = 0;
            let file = 0;
            
            for (let i = 0; i < boardState.length; i++) {
                const char = boardState[i];
                
                if (char === '/') {
                    rank++;
                    file = 0;
                } else if (char >= '1' && char <= '8') {
                    // Empty squares
                    file += parseInt(char);
                } else {
                    // Piece
                    const squareIndex = rank * 8 + file;
                    if (squareIndex < 64) {
                        squares[squareIndex].textContent = getPieceSymbol(char);
                    }
                    file++;
                }
            }
            
            // Update game state display
            updateGameStateDisplay(currentPlayer);
        }

        // Get piece symbol from FEN character
        function getPieceSymbol(fenChar) {
            const pieceMap = {
                'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
                'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
            };
            return pieceMap[fenChar] || '';
        }

        // Update game state display
        function updateGameStateDisplay(currentPlayer) {
            const playerText = currentPlayer === 'w' ? 'White' : 'Black';
            showMessage(`${playerText} to move`, 'info', 2000);
        }

        // Toggle game mode
        function toggleGameMode() {
            gameMode = gameMode === 'analysis' ? 'play' : 'analysis';
            const modeText = gameMode === 'play' ? 'Play Mode' : 'Analysis Mode';
            const modeIcon = gameMode === 'play' ? 'üéÆ' : 'üîç';
            
            showMessage(`${modeIcon} Switched to ${modeText}`, 'info', 3000);
            
            // Update button appearance
            const toggleButton = document.querySelector('button[onclick="toggleGameMode()"]');
            if (toggleButton) {
                toggleButton.classList.remove('play-mode-active', 'analysis-mode-active');
                if (gameMode === 'play') {
                    toggleButton.classList.add('play-mode-active');
                    toggleButton.innerHTML = '<i class="fas fa-gamepad me-1"></i>Exit Play Mode';
                } else {
                    toggleButton.classList.add('analysis-mode-active');
                    toggleButton.innerHTML = '<i class="fas fa-search me-1"></i>Enter Play Mode';
                }
            }
            
            // Clear selection when switching modes
            selectedSquare = null;
            const squares = document.querySelectorAll('.chess-square');
            squares.forEach(sq => {
                sq.classList.remove('selected', 'legal-move');
            });
        }

        // Reset game
        async function resetGame() {
            try {
                const response = await fetch('/api/game/reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage('üîÑ Game reset to starting position', 'success');
                    
                    // Clear selection
                    selectedSquare = null;
                    const squares = document.querySelectorAll('.chess-square');
                    squares.forEach(sq => sq.classList.remove('selected', 'legal-move'));
                    
                    // Reload game state and update board
                    await loadGameState();
                    if (gameState && gameState.fen) {
                        updateBoardFromFEN(gameState.fen);
                    } else {
                        // Fallback to starting position
                        initializeChessBoard();
                    }
                }
            } catch (error) {
                console.error('Reset error:', error);
                showMessage('Error resetting game', 'error', 3000);
            }
        }

        // Stockfish Match Functions
        async function testStockfish() {
            try {
                showMessage('üîç Testing Stockfish availability...', 'info');
                
                const response = await fetch('/api/match/test');
                const result = await response.json();
                
                if (result.success) {
                    showMessage(`‚úÖ ${result.message}\nüìç Path: ${result.path}\nüéØ Test move: ${result.test_move}`, 'success');
                } else {
                    showMessage(`‚ùå Stockfish test failed: ${result.error}`, 'danger');
                }
            } catch (error) {
                console.error('Stockfish test error:', error);
                showMessage('‚ùå Error testing Stockfish', 'danger');
            }
        }

        async function toggleStockfishMatch() {
            if (matchActive) {
                await stopStockfishMatch();
            } else {
                await startStockfishMatch();
            }
        }

        async function startStockfishMatch() {
            try {
                showMessage('üéÆ Starting Stockfish vs Model match...', 'info');
                
                const response = await fetch('/api/match/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model_plays_white: true,
                        time_control: '10+0.1'  // 10 seconds + 0.1s increment
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    matchActive = true;
                    stockfishMatch = result;
                    showMessage(`üèÜ ${result.message}`, 'success');
                    
                    // Update button
                    const button = document.querySelector('button[onclick="toggleStockfishMatch()"]');
                    button.innerHTML = '<i class="fas fa-stop me-1"></i>Stop Match';
                    button.className = 'btn btn-sm btn-danger';
                    
                    // Start playing moves
                    playMatchMoves();
                } else {
                    showMessage(`‚ùå Failed to start match: ${result.error}`, 'danger');
                }
            } catch (error) {
                console.error('Match start error:', error);
                showMessage('‚ùå Error starting match', 'danger');
            }
        }

        async function stopStockfishMatch() {
            try {
                const response = await fetch('/api/match/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    matchActive = false;
                    stockfishMatch = null;
                    showMessage('üõë Match stopped', 'info');
                    
                    // Update button
                    const button = document.querySelector('button[onclick="toggleStockfishMatch()"]');
                    button.innerHTML = '<i class="fas fa-chess me-1"></i>Stockfish Match';
                    button.className = 'btn btn-sm btn-warning';
                }
            } catch (error) {
                console.error('Match stop error:', error);
            }
        }

        async function playMatchMoves() {
            if (!matchActive) return;
            
            try {
                const response = await fetch('/api/match/play', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model_plays_white: true
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const player = result.player;
                    const move = result.san;
                    const time = result.time_taken.toFixed(2);
                    
                    showMessage(`üèÜ ${player} played: ${move} (${time}s)`, 'info');
                    
                    // Update board
                    updateBoardFromFEN(result.fen);
                    
                    if (result.is_game_over) {
                        const gameResult = result.game_result;
                        showMessage(`üèÅ Game Over! Winner: ${gameResult[0].toUpperCase()}, Reason: ${gameResult[1]}`, 'success');
                        matchActive = false;
                        
                        // Update button
                        const button = document.querySelector('button[onclick="toggleStockfishMatch()"]');
                        button.innerHTML = '<i class="fas fa-chess me-1"></i>Stockfish Match';
                        button.className = 'btn btn-sm btn-warning';
                    } else {
                        // Continue playing after a short delay
                        setTimeout(() => playMatchMoves(), 1000);
                    }
                } else {
                    showMessage(`‚ùå Match error: ${result.error}`, 'danger');
                    matchActive = false;
                }
            } catch (error) {
                console.error('Match play error:', error);
                showMessage('‚ùå Error playing match', 'danger');
                matchActive = false;
            }
        }
    </script>
    <script src="{{ url_for('static', filename='js/app.js') }}"></script>
</body>
</html>
